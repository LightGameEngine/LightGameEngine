<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title id="title">Light</title>
    <link href="styles/project.css" rel="stylesheet">
    <script src="scripts/connectionManager.js"></script>
    <script src="scripts/lang.js"></script>
    <script src="scripts/themeManager.js"></script>
</head>
<body>
<div class="body">
    <div class="bar">
        <a onclick="main_menu()" id="lC-cb">
            Close
            <script>lU(() => document.getElementById("lC-cb").innerHTML = m("close-button"))</script>
        </a>
    </div>
    <div style="position: absolute; left: 78%; top: 0.8%; width: 5%">
        <img draggable="false" onclick="setSceneType('game')" id="start_btn" src="../assets/start.png"
             style="position: absolute; top: -0.2%; cursor: pointer" hidden>
        <img draggable="false" onclick="setSceneType('editor')" id="stop_btn" src="../assets/stop.png"
             style="position: absolute; cursor: pointer" hidden>
    </div>
    <div class="left_container_nav">
        <img draggable="false" onclick="open_node_menu()" id="left_nav_add" class="left_nav_add"
             src="../assets/add.png">
        <div style="text-align: center;color: var(--general-color)" id="lC-node">
            <script>lU(() => document.getElementById("lC-node").innerHTML = m("nodes-title"))</script>
        </div>
    </div>
    <div class="left_container">
        <div class="left_container_bar">
            <div class="nodes" id="nodes"></div>
        </div>
    </div>
    <span id="node_menu" class="node_menu" hidden></span>
    <div class="right_container_nav">
        <img draggable="false" onclick="open_property_menu()" id="property-add" hidden class="right_nav_add"
             src="../assets/add.png">
        <img draggable="false"
             onclick="property_delete_mode = !property_delete_mode; select_node(selected_node, true)"
             id="property-remove" hidden class="right_nav_remove"
             src="../assets/trash_closed.png">
        <div style="text-align: center; color: var(--general-color)" id="lC-prp">
            <script>lU(() => document.getElementById("lC-prp").innerHTML = m("properties-title"))</script>
        </div>
    </div>
    <div class="right_container">
        <table id="properties" style="position: absolute; left: -2px; top: -2px"></table>
    </div>
    <div class="console"></div>
    <canvas class="canvas" id="canvas"></canvas>
</div>
<div id="prompt" hidden
     style="position: absolute; left: 0; top: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.2)">
    <div style="position: absolute; left: 30%; padding: 2% 15% 15%;width: 10%; top: 25%; min-height: 10%; height: 15%; background: rgba(0, 0, 0, 0.2)">
        <svg onclick="end_prompt(null)" width="50" height="35" class="prompt_close">
            <path d="M20 12 L30 22 Z" stroke="white"></path>
            <path d="M30 12 L20 22 Z" stroke="white"></path>
        </svg>
        <div style="position: absolute; left: 0; width: 100%">
            <h1 id="prompt-title" style="color: var(--general-color); text-align: center"></h1>
            <div style="text-align: center;"><span id="prompt-error" style="color: red; text-align: center"></span>
            </div>
            <br>
            <div style="text-align: center;"><span id="prompt-text"
                                                   style="color: var(--general-color); text-align: center"></span>
            </div>
            <br>
            <div style="text-align: center;"><input spellcheck="false" maxlength="16" id="prompt-input"
                                                    class="prompt_input"></div>
            <br>
            <div style="text-align: center;">
                <button class="btn" id="prompt-button"
                        onclick="end_prompt(document.getElementById('prompt-input').value)"></button>
            </div>
        </div>
    </div>
</div>
</body>
<script src="scripts/engine.js"></script>
<script src="scripts/PathFinder.js"></script>
<script>
    document.getElementById("prompt-input").addEventListener("keydown", ev => ev.key === "Enter" ? document.getElementById("prompt-button").click() : null);
    /*** @type {HTMLCanvasElement} */
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");

    const node_types = ["entity", "model", "collision", "tile"/*, "tile-map"*/, "script"];

    const start_btn = document.getElementById("start_btn");
    const stop_btn = document.getElementById("stop_btn");

    function open_node_menu() {
        document.getElementById("node_menu").innerHTML = node_types.map(i => `<span onclick="open_add_node_menu('${i}')" class="node_select">${languages[lang]["node-" + i]}</span>`).join("<br>");
        document.getElementById("node_menu").hidden = undefined;
    }

    let property_delete_mode = false;

    function open_property_menu() {
        if (!selected_node) return;
        prompt(
            languages[lang]["add-property-title"],
            languages[lang]["property-name"],
            languages[lang]["add-button"]
        )
            .then(r => {
                if (r === null) return;
                if (!selected_node) return;
                if (!r || r.split("").some(i => !"abcçdefgğhıijklmnoprsştuüvyzqwx0123456789".split("").some(a => a.toLowerCase() === i.toLowerCase())) || "0123456789".split("").some(i => r.endsWith(i))) {
                    open_property_menu();
                    return document.getElementById("prompt-error").innerHTML = languages[lang]["invalid-property-name"];
                }
                if (!project.json.nodes[selected_node] || !selected_node) {
                    open_property_menu();
                    return document.getElementById("prompt-error").innerHTML = languages[lang]["node-not-selected"];
                }
                if (project.json.nodes[selected_node].properties[r]) {
                    open_property_menu();
                    return document.getElementById("prompt-error").innerHTML = languages[lang]["property-exists"];
                }
                add_node_property(selected_node, r);
            });
    }

    let _p_c = null;

    function end_prompt(res) {
        if (_p_c) _p_c(res);
        _p_c = null;
        document.getElementById("prompt").hidden = true;
    }

    function prompt(title, text, button, input = true) {
        return new Promise(r => {
            document.getElementById("prompt-title").innerHTML = title;
            document.getElementById("prompt-text").innerHTML = text;
            document.getElementById("prompt-input").value = "";
            document.getElementById("prompt-input").hidden = input ? undefined : true;
            document.getElementById("prompt-button").innerHTML = button;
            document.getElementById("prompt-error").innerHTML = "";
            document.getElementById("prompt").hidden = undefined;
            _p_c = r;
        });
    }

    const modelTypes = ["image", "text", "rectangle", "circle"];

    function open_rename_node_menu(oldName) {
        prompt(
            languages[lang]["rename-node-title"],
            languages[lang]["enter-node-new-name"] + ":",
            languages[lang]["rename-node-button"]
        ).then(r => {
            if (r === null) return;
            if (!r || r.split("").some(i => i !== "İ" && !"abcçdefgğhıijklmnoöprsştuüvyzqwx1234567890 ".includes(i.toLowerCase()))) {
                open_rename_node_menu(oldName);
                return document.getElementById("prompt-error").innerHTML = languages[lang]["invalid-node"];
            }
            rename_node(oldName, r);
        });
        document.getElementById("prompt-input").value = oldName;
    }

    function open_add_node_menu(type) {
        prompt(
            languages[lang]["add-node-title"],
            languages[lang]["enter-node-name"] + `:<br>
<div style="text-align: center;"><input spellcheck="false" maxlength="16" id="add-node-name" class="prompt_input"></div><br>
<span${type !== "model" ? " hidden" : ""}>${languages[lang]["select-model-type"]}:<br><div style="text-align: center;"><select id="add-node-type" class="prompt_input">${modelTypes.map(i => `<option style="background: var(--body-background)" value="${i}">${languages[lang]["model-type-" + i]}</option>`).join("")}</select></div></span>`,
            languages[lang]["add-node-button"],
            false
        ).then(r => {
            if (r === null) return;
            let name = document.getElementById("add-node-name").value;
            let modelType = document.getElementById("add-node-type").value;
            if (name) {
                if (name.split("").some(i => i !== "İ" && !"abcçdefgğhıijklmnoöprsştuüvyzqwx1234567890 ".includes(i.toLowerCase()))) {
                    open_add_node_menu(type);
                    return document.getElementById("prompt-error").innerHTML = languages[lang]["invalid-node"];
                }
                add_node(type + (type === "model" ? "-" + modelType : ""), name);
            } else if (name !== null) {
                open_add_node_menu(type);
                document.getElementById("prompt-error").innerHTML = languages[lang]["invalid-node"];
            }
        });
    }

    function add_node(type, name) {
        if (project.json.nodes[name]) {
            open_add_node_menu(type.startsWith("model") ? "model" : type);
            document.getElementById("prompt-error").innerHTML = languages[lang]["node-exists"];
            return;
        }
        ws.sendPacket("add_node", {path: project.path, node: {name, type}});
        project.json.nodes[name] = {name, type};
        ws.sendPacket("get_projects");
        addWSOnceListener("get_projects", () => select_node(name))
    }

    function open_remove_node_menu(name) {
        prompt(
            languages[lang]["remove-node-title"],
            languages[lang]["node-remove-text"].replace("%0", name),
            languages[lang]["remove-node-button"],
            false
        ).then(r => r === "" && remove_node(name));
    }

    function remove_node(name) {
        ws.sendPacket("remove_node", {path: project.path, name});
        delete project.json.nodes[name];
        if (name === selected_node) select_node(null);
        refresh_nodes();
    }

    function add_node_property(name, property) {
        project.json.nodes[name].properties[property] = {
            value: "",
            default: ""
        };
        ws.sendPacket("set_node_properties", {
            path: project.path,
            name,
            properties: project.json.nodes[name].properties
        });
        refresh_properties();
        ws.sendPacket("get_projects");
    }

    function remove_node_property(name, property) {
        delete project.json.nodes[name].properties[property];
        ws.sendPacket("set_node_properties", {
            path: project.path,
            name,
            properties: project.json.nodes[name].properties
        });
        refresh_properties();
    }

    function set_node_property(nodeName, propertyName, propertyValue) {
        if (!project.json.nodes[nodeName] || !project.json.nodes[nodeName].properties[propertyName]) return;
        const node = project.json.nodes[nodeName];
        const prop = node.properties[propertyName];
        switch (prop.type) {
            case "boolean":
                break;
            case "color":
                break;
            case "number":
                if (prop.array) {
                    propertyValue = (propertyValue || "").split(",").map(j => j.toString().split("").filter(i => !isNaN(i * 1) || i === "-" || i === ".").join("")).map(i => i.length !== 0 ? i * 1 : undefined).filter(i => i !== undefined).map(i => isNaN(i) ? prop.default : i).join(",");
                } else {
                    if (propertyValue.length !== 0) propertyValue *= 1;
                    else propertyValue = prop.default;
                    if (isNaN(propertyValue)) propertyValue = prop.default;
                    if (prop.isDefaultProperty && propertyName === "opacity") {
                        if (propertyValue < 0) propertyValue = 0;
                        if (propertyValue > 1) propertyValue = 1;
                    }
                }
                break;
            case "model":
                if (prop.array) {
                    propertyValue = Array.from(new Set((propertyValue || "").split(",").filter(i => project.json.nodes[i] && project.json.nodes[i].type.startsWith("model-") && nodeName !== i))).join(",");
                } else {
                    if (!project.json.nodes[propertyValue] || nodeName === propertyValue) propertyValue = prop.default;
                }
                break;
            case "collision":
            case "script":
                if (prop.array) {
                    propertyValue = Array.from(new Set((propertyValue || "").split(",").filter(i => project.json.nodes[i] && project.json.nodes[i].type === prop.type && nodeName !== i))).join(",");
                } else {
                    if (!project.json.nodes[propertyValue] || nodeName === propertyValue) propertyValue = prop.default;
                }
                break;
        }

        if (selected_node === nodeName) {
            switch (prop.type) {
                case "boolean":
                    document.getElementById("node_property_" + propertyName).checked = propertyValue;
                    break;
                default:
                    document.getElementById("node_property_" + propertyName).value = propertyValue;
                    break;
            }
        }
        node.properties[propertyName].value = propertyValue;
        ws.sendPacket("set_node_properties", {
            path: project.path, name: nodeName, properties: node.properties
        });
        if (sceneType === "editor") setSceneType("editor");
    }

    function set_node_properties(nodeName, properties) {
        if (!project.json.nodes[nodeName]) return;
        project.json.nodes[nodeName].properties = properties;
        ws.sendPacket("set_node_properties", {
            path: project.path, name: nodeName, properties
        });
    }

    function rename_node(name, newName) {
        let old = project.json.nodes[name];
        remove_node(name);
        add_node(old.type, newName);
        set_node_properties(newName, old.properties);
        ws.sendPacket("set_node_position", {
            path: project.path, node: newName, position: old.position
        });
        ws.sendPacket("get_projects");
        addWSOnceListener("get_projects", () => select_node(newName));
    }

    function switch_node_positions(a, b) {
        ws.sendPacket("switch_node_positions", {path: project.path, from: a, to: b});
        ws.sendPacket("get_projects");
    }

    addEventListener("click", ev => {
        if (!ev.path.some(i => i.id === "node_menu" || i.id === "left_nav_add"))
            document.getElementById("node_menu").hidden = true;
    });

    let selected_node = null;

    function refresh_nodes() {
        document.getElementById("nodes").innerHTML = Object.keys(project.json.nodes).sort((a, b) => {
            a = project.json.nodes[a];
            b = project.json.nodes[b];
            return a.position - b.position;
        }).map(key => `
<div draggable="true" id="node_key_${key}">
    <div class="node${selected_node === key ? " node_selected" : ""}" onclick="select_node('${key}')">
        <img draggable="false" class="node_image" src="../assets/${project.json.nodes[key].type.replaceAll("-", "_")}.png">
        <span class="node_name">${key}</span>
    </div>
    <div onclick="open_remove_node_menu('${key}')" class="remove_node"></div>
    <div onclick="open_rename_node_menu('${key}')" class="rename_node"></div>
</div>`).join("");
        Object.keys(project.json.nodes).forEach(key => {
            const el = document.getElementById("node_key_" + key);
            el.addEventListener("dragstart", ev => ev.dataTransfer.setData("DragID", ev.target.id));
            el.addEventListener("dragover", ev => {
                ev.preventDefault();
                el.style.border = "5px solid white";
            });
            el.addEventListener("dragleave", () => el.style.border = "");
            el.addEventListener("drop", ev => {
                ev.preventDefault();
                const dragged = ev.dataTransfer.getData("DragID");
                if (ev.path.some(i => i.id && i.id.startsWith("node_key_") && i.id !== dragged)) {
                    switch_node_positions(key, dragged.replace("node_key_", ""));
                } else el.style.border = "";
            });
        });
    }

    function refresh_properties() {
        if (!selected_node || !project.json.nodes[selected_node]) return document.getElementById("properties").innerHTML = "";
        const props = project.json.nodes[selected_node].properties;
        document.getElementById("properties").innerHTML = Object.keys(props).filter(i => props[i].visible !== false).map(key => {
            let input = `<input onchange="set_node_property('${selected_node}', '${key}', document.getElementById('node_property_${key}').value)" id="node_property_${key}" spellcheck="false" class="property_value" style="position: absolute; margin-left: -3px; margin-top: -10px; height: 19px" value="${props[key].value === null ? "" : props[key].value}" placeholder="<${languages[lang]["none"]}>">`;
            switch (props[key].type) {
                case "boolean":
                    input = `<input onchange="set_node_property('${selected_node}', '${key}', !!document.getElementById('node_property_${key}').checked)" id="node_property_${key}" type="checkbox" ${props[key].value ? "checked" : ""}>`;
                    break;
                case "color":
                    input = `<input onchange="set_node_property('${selected_node}', '${key}', document.getElementById('node_property_${key}').value)" id="node_property_${key}" type="color" value="${props[key].value}">`
                    break;
            }
            return `
<tr><td class="property_name${property_delete_mode && !props[key].isDefaultProperty ? ` remove_mode` : ""}"${property_delete_mode && !props[key].isDefaultProperty ? `onclick="remove_node_property(selected_node, '${key}')"` : ""}>${props[key].isDefaultProperty ? languages[lang]["property--" + key] : key}</td><td>
${input}
</td></tr>
`;
        }).join("");
    }

    function select_node(name, v = false) {
        if (selected_node === name && !v) {
            name = null;
            property_delete_mode = false;
        }
        document.getElementById("property-remove").src = property_delete_mode ? '../assets/trash_closed_red.png' : '../assets/trash_closed.png';
        document.getElementById("property-add").hidden = name ? undefined : true;
        document.getElementById("property-remove").hidden = name ? undefined : true;
        selected_node = name;
        refresh_properties();
        refresh_nodes();
    }

    let project = {};
    addWSListener("get_language", () => setLanguage(lang, false));
    addWSListener("get_projects", ({projects}) => {
        project = projects[query.path];
        document.getElementById("title").innerHTML = "Light - " + project.name;
        refresh_nodes();
    });
    ws.sendPacket("get_projects");
    /*** @type {"editor" | "game"} */
    let sceneType;
    let sceneCamera = new Vector2(0, 0);
    Scene.ctx = ctx;
    let modelList = {};
    let collisionList = {};
    let scriptList = {};

    const createModel = async ({type, properties}) => {
        switch (type) {
            case "model-image":
                const model = new ImageModel(
                    properties.x.value * 1,
                    properties.y.value * 1,
                    properties.width.value * 1,
                    properties.height.value * 1,
                    properties.opacity.value * 1
                );
                if (properties.image.value) model.setImage(await ImageModel.loadImage(properties.image.value));
                return model;
            case "model-text":
                return new TextModel(
                    properties.x.value * 1,
                    properties.y.value * 1,
                    properties.text.value,
                    properties.font.value,
                    properties.size.value * 1,
                    properties.color.value,
                    properties.maxWidth.value * 1 || null,
                    properties.opacity.value * 1
                );
            case "model-rectangle":
                return new RectangleModel(
                    properties.x.value * 1,
                    properties.y.value * 1,
                    properties.width.value * 1,
                    properties.height.value * 1,
                    properties.fillColor.value,
                    properties.strokeColor.value,
                    properties.opacity.value * 1
                );
            case "model-circle":
                return new CircleModel(
                    properties.x.value * 1,
                    properties.y.value * 1,
                    properties.radius.value,
                    properties.fillColor.value,
                    properties.strokeColor.value,
                    properties.opacity.value * 1
                );
        }
        return null;
    };
    const createCollision = props => {
        return new RectangleCollision(
            props.x.value * 1,
            props.y.value * 1,
            props.width.value * 1,
            props.height.value * 1
        );
    };
    const createEntity = async props => {
        const entity = new Entity(props.x.value * 1, props.y.value * 1);
        (props.models.value || "").split(",").forEach(m => {
            const mdl = project.json.nodes[m];
            if (mdl) entity.addModel(modelList[m]);
        });
        (props.collisions.value || "").split(",").forEach(m => {
            const cls = project.json.nodes[m];
            if (cls) entity.addCollision(collisionList[m]);
        });
        entity.rotation = props.rotation.value;
        entity.gravityEnabled = props.gravityEnabled.value;
        entity.gravity = props.gravity.value;
        entity.terminalGravityVelocity = props.terminalGravityVelocity.value;
        entity.motionDivision = new Vector2(props.motionDivision.value, props.motionDivision.value);
        entity.visible = !props.invisible.value;
        return entity;
    };
    const createTile = async props => {
        const tile = new Tile(props.x.value * 1, props.y.value * 1);
        props.models.value.split(",").forEach(m => {
            const mdl = project.json.nodes[m];
            if (mdl) tile.addModel(modelList[m]);
        });
        props.collisions.value.split(",").forEach(m => {
            const cls = project.json.nodes[m];
            if (cls) tile.addCollision(collisionList[m]);
        });
        tile.rotation = props.rotation.value;
        tile.visible = !props.invisible.value;
        return tile;
    };
    const refreshModelList = async () => {
        modelList = {};
        const loadingModels = Object.keys(project.json.nodes).filter(i => project.json.nodes[i].type.startsWith("model-"));
        for (let i = 0; i < loadingModels.length; i++) {
            const m = loadingModels[i];
            const n = project.json.nodes[m];
            modelList[m] = await createModel(n);
        }
    }
    const refreshCollisionList = async () => {
        collisionList = {};
        const loadingCollisions = Object.keys(project.json.nodes).filter(i => project.json.nodes[i].type === "collision");
        for (let i = 0; i < loadingCollisions.length; i++) {
            const m = loadingCollisions[i];
            const n = project.json.nodes[m];
            collisionList[m] = createCollision(n.properties);
        }
    }
    const refreshScriptList = async () => {
        scriptList = {};
        const loadingScripts = Object.keys(project.json.nodes).filter(i => project.json.nodes[i].type === "script");
        for (let i = 0; i < loadingScripts.length; i++) {
            const m = loadingScripts[i];
            const n = project.json.nodes[m];
            if (n.properties.file.value) scriptList[m] = await loadScript(n.properties.file.value);
        }
    }

    canvas.addEventListener("keypress", ev => {
    });

    let canvasMouseDown = null;
    let selectedEditorEntity = null;
    const mouse = new Vector2(0, 0);

    addEventListener("mousemove", ev => {
        mouse.x = ev.clientX;
        mouse.y = ev.clientY;
    });

    canvas.addEventListener("mousemove", ev => {
        if (!canvasMouseDown) return;
        if (selectedEditorEntity) {
            const pos = (new Vector2(ev.offsetX, ev.offsetY)).subtract(sceneCamera);
            const nodeId = selectedEditorEntity["nodeId"];
            project.json.nodes[nodeId].properties.x.value = pos.x;
            project.json.nodes[nodeId].properties.y.value = pos.y;
            refresh_properties();
            setSceneType("editor");
        } else {
            const newCamera = canvasMouseDown[1].subtract(canvasMouseDown[0].subtract(ev.offsetX, ev.offsetY));
            sceneCamera.x = newCamera.x;
            sceneCamera.y = newCamera.y;
        }
    });

    const getEntityByMouse = (x, y) => {
        return Scene.getInstance().entities.find(entity => entity instanceof Entity && entity.collides(new Vector2(x - sceneCamera.x, y - sceneCamera.y)))
    };

    canvas.addEventListener("mousedown", ev => {
        canvasMouseDown = [new Vector2(ev.offsetX, ev.offsetY), Scene.getInstance().camera.clone()];
        if (sceneType === "editor") {
            selectedEditorEntity = getEntityByMouse(ev.offsetX, ev.offsetY);
        }
    });

    addEventListener("mouseup", ev => {
        if (sceneType === "editor" && canvasMouseDown && canvasMouseDown[0] && canvasMouseDown[0].equals(new Vector2(ev.offsetX, ev.offsetY))) {
            const ent = getEntityByMouse(ev.offsetX, ev.offsetY);
            if (ent && ent["nodeId"]) select_node(ent["nodeId"]);
        }
        if (selectedEditorEntity && canvasMouseDown) {
            const nodeId = selectedEditorEntity["nodeId"];
            set_node_properties(nodeId, project.json.nodes[nodeId].properties);
        }
        selectedEditorEntity = null;
        canvasMouseDown = false;
    });
    let setupCamera = false;

    async function setSceneType(type) {
        sceneType = type;
        switch (sceneType) {
            case "editor":
                Scene.getInstance().destroy();
                Scene.getInstance().camera = sceneCamera;
                Scene.getInstance().onUpdateStart = () => {
                    ctx.fillStyle = "rgb(0, 255, 0)";
                    ctx.fillRect(0, sceneCamera.y, canvas.width, 1);
                    ctx.fillStyle = "rgb(255, 0, 0)";
                    ctx.fillRect(sceneCamera.x, 0, 1, canvas.height);
                }
                if (!setupCamera) {
                    setupCamera = true;
                    sceneCamera.x = canvas.width / 2;
                    sceneCamera.y = canvas.height / 2;
                }
                await refreshModelList();
                await refreshCollisionList();
                const nList = Object.keys(project.json.nodes).filter(i => ["entity", "tile"].includes(project.json.nodes[i].type));
                for (const j of nList) {
                    const i1 = project.json.nodes[j];
                    switch (i1.type) {
                        case "entity":
                            const entity = await createEntity(i1.properties);
                            entity.update = r => r;
                            if (entity) entity.init();
                            entity.nodeId = j;
                            entity.collisions.forEach(i => {
                                if (!(i instanceof RectangleCollision)) return;
                                const t = new Tile(entity.x, entity.y);
                                t.addModel(new RectangleModel(i.offsetX, i.offsetY, i.width, i.height, null, "#ffffff"));
                                t.init();
                            });
                            break;
                        case "tile":
                            const tile = await createTile(i1.properties);
                            tile.update = r => r;
                            if (tile) tile.init();
                            tile.nodeId = j;
                            tile.collisions.forEach(i => {
                                if (!(i instanceof RectangleCollision)) return;
                                const t = new Tile(tile.x, tile.y);
                                t.addModel(new RectangleModel(i.offsetX, i.offsetY, i.width, i.height, null, "#ffffff"));
                                t.init();
                            });
                            break;
                    }
                }
                start_btn.hidden = undefined;
                stop_btn.hidden = true;
                break;
            case "game":
                Scene.getInstance().destroy();
                Scene.getInstance();
                await refreshModelList();
                await refreshCollisionList();
                for (const i1 of Object.values(project.json.nodes).filter(i => ["entity", "tile"].includes(i.type))) {
                    switch (i1.type) {
                        case "entity":
                            const entity = await createEntity(i1.properties);
                            if (entity) entity.init();
                            break;
                        case "tile":
                            const tile = await createTile(i1.properties);
                            if (tile) tile.init();
                            break;
                    }
                }
                start_btn.hidden = true;
                stop_btn.hidden = undefined;
                break;
        }
    }

    addWSOnceListener("get_projects", () => setSceneType("editor"));

    function main_menu() {
        window.location.href = "index.html";
        ws.sendPacket("main_menu");
    }

    const _query = decodeURI(window.location.href).toString().split("?").slice(1).join("").split("&").map(i => [i.split("=")[0], i.split("=").slice(1).join("")]);
    const query = {};
    _query.forEach(i => query[i[0]] = i[1]);

    setInterval(() => {
        const canvas = document.getElementById("canvas");
        if (canvas.width !== Math.floor(window.innerWidth * 0.601)) canvas.width = Math.floor(window.innerWidth * 0.601);
        if (canvas.height !== Math.floor(window.innerHeight * 0.751)) canvas.height = Math.floor(window.innerHeight * 0.751);
    });

    addWSListener("get_file", ({path, exists, type}) => {
        if (path === query.path && (!exists || type !== "folder")) main_menu();
    });

    function checkProjectExists() {
        ws.sendPacket("get_file", {path: query.path});
    }

    window.addEventListener("blur", checkProjectExists);
</script>
</html>
