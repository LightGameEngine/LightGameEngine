<!DOCTYPE html>
<html lang="en">
<head>
    <script>document._cc = console;</script>
    <meta charset="UTF-8">
    <title id="title">Light</title>
    <link href="styles/project.css" rel="stylesheet">
    <script src="scripts/connectionManager.js"></script>
    <script src="scripts/lang.js"></script>
    <script src="scripts/themeManager.js"></script>
</head>
<body style="overflow-x: hidden">
<div class="body">
    <div class="bar">
        <a onclick="document._light.main_menu()" id="lC-cb">
            Close
            <script>lU(() => document.getElementById("lC-cb").innerHTML = m("close-button"))</script>
        </a>&nbsp;&nbsp;
        <a onclick="document._light.open_logs()" id="lC-cbb">
            <script>lU(() => document.getElementById("lC-cbb").innerHTML = m("logs-button"))</script>
        </a>
    </div>
    <div style="position: absolute; left: 78%; top: 0.8%; width: 5%">
        <img draggable="false" onclick="document._light.setSceneType('game')" id="start_btn" src="../assets/start.png"
             style="position: absolute; top: -0.2%; cursor: pointer" hidden>
        <img draggable="false" onclick="document._light.setSceneType('editor')" id="stop_btn" src="../assets/stop.png"
             style="position: absolute; cursor: pointer" hidden>
    </div>
    <div class="left_container_nav">
        <img draggable="false" onclick="document._light.open_node_menu()" id="left_nav_add" class="left_nav_add"
             src="../assets/add.png">
        <div style="text-align: center;color: var(--general-color)" id="lC-node">
            <script>lU(() => document.getElementById("lC-node").innerHTML = m("nodes-title"))</script>
        </div>
    </div>
    <div class="left_container">
        <div class="left_container_bar">
            <div class="nodes" id="nodes"></div>
        </div>
    </div>
    <span id="node_menu" class="node_menu" hidden></span>
    <div class="right_container_nav">
        <img draggable="false" onclick="document._light.open_property_menu()" id="property-add" hidden
             class="right_nav_add"
             src="../assets/add.png">
        <img draggable="false"
             onclick="document._light.property_delete_mode = !document._light.property_delete_mode; document._light.refresh_properties()"
             id="property-remove" hidden class="right_nav_remove"
             src="../assets/trash_closed.png">
        <img draggable="false"
             onclick="document._light.selected_node?document._light.block_code(document._light.selected_node):null"
             id="node-block-script" hidden class="right_nav_script"
             src="../assets/script.png">
        <div style="text-align: center; color: var(--general-color)" id="lC-prp">
            <script>lU(() => document.getElementById("lC-prp").innerHTML = m("properties-title"))</script>
        </div>
    </div>
    <div class="right_container">
        <table id="properties" style="position: absolute; left: -2px; top: -2px"></table>
    </div>
    <div class="console" id="console"></div>
    <canvas class="canvas" id="canvas"></canvas>
</div>
<div id="prompt" hidden
     style="position: absolute; left: 0; top: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.2)">
    <div style="position: absolute; left: 30%; padding: 2% 15% 15%;width: 10%; top: 25%; min-height: 10%; height: 15%; background: var(--popup)">
        <svg onclick="document._light.end_prompt(null)" width="50" height="35" class="prompt_close">
            <path d="M20 12 L30 22 Z" stroke="white"></path>
            <path d="M30 12 L20 22 Z" stroke="white"></path>
        </svg>
        <div style="position: absolute; left: 0; width: 100%">
            <h1 id="prompt-title" style="color: var(--general-color); text-align: center"></h1>
            <div style="text-align: center;"><span id="prompt-error" style="color: red; text-align: center"></span>
            </div>
            <br>
            <div style="text-align: center;"><span id="prompt-text"
                                                   style="color: var(--general-color); text-align: center"></span>
            </div>
            <br>
            <div style="text-align: center;"><input spellcheck="false" maxlength="16" id="prompt-input"
                                                    class="prompt_input"></div>
            <br>
            <div style="text-align: center;">
                <button class="btn" id="prompt-button"
                        onclick="document._light.end_prompt(document.getElementById('prompt-input').value)"></button>
            </div>
        </div>
    </div>
</div>
</body>
<script src="scripts/engine.js"></script>
<script>
    (() => {
        addEventListener("keydown", ev => ev.key === "Enter" ? end_prompt(document.getElementById('prompt-input').value) : null);
        const letters = "abcçdefgğhıijklmnoprsştuüvyzqwx";
        document.getElementById("prompt-input").addEventListener("keydown", ev => ev.key === "Enter" ? document.getElementById("prompt-button").click() : null);
        /*** @type {HTMLCanvasElement} */
        const canvas = document.getElementById("canvas");
        const ctx = canvas.getContext("2d");

        const _query = decodeURI(window.location.href).toString().split("?").slice(1).join("").split("&").map(i => [i.split("=")[0], i.split("=").slice(1).join("")]);
        const query = {};
        _query.forEach(i => query[i[0]] = i[1]);

        document._light = {project: null};

        const node_types = ["entity", "model", "collision", "text", "tile", "light"/*, "tile-map"*/, "script", "group"];

        const start_btn = document.getElementById("start_btn");
        const stop_btn = document.getElementById("stop_btn");
        let consoleList = [];
        const renderConsole = (str) => {
            const cns = document.getElementById("console");
            if (str) {
                if (consoleList.length > 0 && consoleList[consoleList.length - 1].value === str) consoleList[consoleList.length - 1].stack++;
                else consoleList.push({value: str, stack: 1});
            }
            cns.innerHTML = consoleList.map(i => `${i.stack > 1 ? "[x" + i.stack + "]" : ""} ${i.value}`).join("<br>");
            cns.scrollTop = cns.scrollHeight;
        }
        printHandler = renderConsole;

        function open_node_menu() {
            document.getElementById("node_menu").innerHTML = node_types.map(i => `<span onclick="document._light.open_add_node_menu('${i}')" class="node_select">${languages[lang]["node-" + i]}</span>`).join("<br>");
            document.getElementById("node_menu").hidden = undefined;
        }

        function open_property_menu() {
            if (!document._light.selected_node) return;
            prompt(
                languages[lang]["add-property-title"],
                languages[lang]["property-name"],
                languages[lang]["add-button"]
            ).then(r => {
                if (r === null) return;
                if (!document._light.selected_node) return;
                const node = document._light.project.json.nodes[document._light.selected_node];
                if (!r || r.split("").some(i => !(letters + "0123456789").split("").some(a => a.toLowerCase() === i.toLowerCase())) || "0123456789".split("").some(i => r.endsWith(i))) {
                    open_property_menu();
                    return document.getElementById("prompt-error").innerHTML = languages[lang]["invalid-property-name"];
                }
                if (!node) {
                    open_property_menu();
                    return document.getElementById("prompt-error").innerHTML = languages[lang]["node-not-selected"];
                }
                const extraProps = {
                    entity: Entity.PROPERTIES,
                    "model-image": ImageModel.PROPERTIES,
                    "model-text": TextModel.PROPERTIES,
                    "model-rectangle": RectangleModel.PROPERTIES,
                    "model-circle": CircleModel.PROPERTIES,
                    collision: RectangleCollision.PROPERTIES,
                    tile: Tile.PROPERTIES,
                    light: RayCastEntity.PROPERTIES
                }[node.type] || [];
                if (node.properties[r] || Object.values(extraProps).some(i => i.includes(r)) || r === "__nodeId") {
                    open_property_menu();
                    return document.getElementById("prompt-error").innerHTML = languages[lang]["property-exists"];
                }
                add_node_property(document._light.selected_node, r);
            });
        }

        let _p_c = null;

        function end_prompt(res) {
            if (_p_c) _p_c(res);
            _p_c = null;
            document.getElementById("prompt").hidden = true;
        }

        function prompt(title, text, button, input = true) {
            return new Promise(r => {
                document.getElementById("prompt-title").innerHTML = title;
                document.getElementById("prompt-text").innerHTML = text;
                document.getElementById("prompt-input").value = "";
                document.getElementById("prompt-input").hidden = input ? undefined : true;
                document.getElementById("prompt-button").innerHTML = button;
                document.getElementById("prompt-error").innerHTML = "";
                document.getElementById("prompt").hidden = undefined;
                _p_c = r;
            });
        }

        const modelTypes = ["image", "text", "rectangle", "circle", "custom"];

        function open_rename_node_menu(oldName) {
            prompt(
                languages[lang]["rename-node-title"],
                languages[lang]["enter-node-new-name"] + ":",
                languages[lang]["rename-node-button"]
            ).then(r => {
                if (r === null) return;
                if (!r || r.split("").some(i => i !== "İ" && !(letters + "1234567890 ").includes(i.toLowerCase()))) {
                    open_rename_node_menu(oldName);
                    return document.getElementById("prompt-error").innerHTML = languages[lang]["invalid-node"];
                }
                if (document._light.project.json.nodes[r]) {
                    open_rename_node_menu(oldName);
                    return document.getElementById("prompt-error").innerHTML = languages[lang]["node-exists"];
                }
                rename_node(oldName, r);
            });
            document.getElementById("prompt-input").value = oldName;
        }

        function open_add_node_menu(type) {
            prompt(
                languages[lang]["add-node-title"],
                languages[lang]["enter-node-name"] + `:<br>
<div style="text-align: center;"><input spellcheck="false" maxlength="16" id="add-node-name" class="prompt_input"></div><br>
<span${type !== "model" ? " hidden" : ""}>${languages[lang]["select-model-type"]}:<br><div style="text-align: center;"><select id="add-node-type" class="prompt_input">${modelTypes.map(i => `<option style="background: var(--body-background)" value="${i}">${languages[lang]["model-type-" + i]}</option>`).join("")}</select></div></span>`,
                languages[lang]["add-node-button"],
                false
            ).then(r => {
                if (r === null) return;
                let name = document.getElementById("add-node-name").value;
                let modelType = document.getElementById("add-node-type").value;
                if (name) {
                    if (name.split("").some(i => i !== "İ" && !(letters + "1234567890 ").includes(i.toLowerCase()))) {
                        open_add_node_menu(type);
                        return document.getElementById("prompt-error").innerHTML = languages[lang]["invalid-node"];
                    }
                    add_node(type + (type === "model" ? "-" + modelType : ""), name);
                } else if (name !== null) {
                    open_add_node_menu(type);
                    document.getElementById("prompt-error").innerHTML = languages[lang]["invalid-node"];
                }
            });
        }

        function add_node(type, name) {
            if (document._light.project.json.nodes[name]) {
                open_add_node_menu(type.startsWith("model") ? "model" : type);
                document.getElementById("prompt-error").innerHTML = languages[lang]["node-exists"];
                return;
            }
            ws.sendPacket("add_node", {path: document._light.project.path, node: {name, type}});
            document._light.project.json.nodes[name] = {name, type};
            ws.sendPacket("get_projects");
            addWSOnceListener("get_projects", () => select_node(name));
        }

        function open_remove_node_menu(name) {
            prompt(
                languages[lang]["remove-node-title"],
                languages[lang]["node-remove-text"].replace("%0", name),
                languages[lang]["remove-node-button"],
                false
            ).then(r => r === "" && remove_node(name));
        }

        function remove_node(name) {
            ws.sendPacket("remove_node", {path: document._light.project.path, name});
            ws.sendPacket("get_projects");
        }

        function add_node_property(name, property) {
            document._light.project.json.nodes[name].properties[property] = {
                value: "",
                default: ""
            };
            ws.sendPacket("set_node_properties", {
                path: document._light.project.path,
                name,
                properties: document._light.project.json.nodes[name].properties
            });
            refresh_properties();
            ws.sendPacket("get_projects");
        }

        function remove_node_property(name, property) {
            delete document._light.project.json.nodes[name].properties[property];
            ws.sendPacket("set_node_properties", {
                path: document._light.project.path,
                name,
                properties: document._light.project.json.nodes[name].properties
            });
            refresh_properties();
        }

        function set_node_property(nodeName, propertyName, propertyValue) {
            if (!document._light.project.json.nodes[nodeName] || !document._light.project.json.nodes[nodeName].properties[propertyName]) return;
            const node = document._light.project.json.nodes[nodeName];
            const prop = node.properties[propertyName];
            switch (prop.type) {
                case "percent":
                case "number":
                    if (prop.array) {
                        propertyValue = (propertyValue || "").split(",").map(j => j.toString().split("").filter(i => !isNaN(i * 1) || i === "-" || i === ".").join("")).map(i => i.length !== 0 ? i * 1 : undefined).filter(i => i !== undefined).map(i => isNaN(i) ? prop.default : i).join(",");
                    } else {
                        if (propertyValue.length !== 0) propertyValue *= 1;
                        else propertyValue = prop.default;
                        if (isNaN(propertyValue)) propertyValue = prop.default;
                        if (prop.isDefaultProperty && propertyName === "opacity") {
                            if (propertyValue < 0) propertyValue = 0;
                            if (propertyValue > 1) propertyValue = 1;
                        }
                    }
                    break;
                case "model":
                case "collision":
                case "node":
                    if (prop.array) {
                        propertyValue = Array.from(new Set((propertyValue || "").split(",").filter(i => document._light.project.json.nodes[i] && (prop.type === "model" ? document._light.project.json.nodes[i].type.startsWith("model-") : (document._light.project.json.nodes[i].type === prop.type || prop.type === "node")) && nodeName !== i))).join(",");
                    } else {
                        if (!document._light.project.json.nodes[propertyValue] || (prop.type === "model" ? document._light.project.json.nodes[propertyValue].type.startsWith("model-") : (document._light.project.json.nodes[propertyValue].type !== prop.type || prop.type === "node")) || nodeName === propertyValue) propertyValue = prop.default;
                    }
                    break;
                case undefined:
                    propertyValue = !isNaN(propertyValue) ? propertyValue * 1 : propertyValue;
                    break;
            }

            if (document._light.selected_node === nodeName) {
                switch (prop.type) {
                    case "boolean":
                        document.getElementById("node_property_" + propertyName).checked = propertyValue;
                        break;
                    default:
                        document.getElementById("node_property_" + propertyName).value = propertyValue;
                        break;
                }
            }
            node.properties[propertyName].value = propertyValue;
            ws.sendPacket("set_node_properties", {
                path: document._light.project.path, name: nodeName, properties: node.properties
            });
            if (sceneType === "editor") setSceneType("editor");
        }

        function set_node_properties(nodeName, properties) {
            if (!document._light.project.json.nodes[nodeName]) return;
            document._light.project.json.nodes[nodeName].properties = properties;
            ws.sendPacket("set_node_properties", {
                path: document._light.project.path, name: nodeName, properties
            });
        }

        function rename_node(from, to) {
            document._light.project.json.nodes[to] = document._light.project.json.nodes[from];
            delete document._light.project.json.nodes[from];
            ws.sendPacket("rename_node", {path: document._light.project.path, from, to});
            select_node(to);
            if (sceneType === "editor") setSceneType("editor");
        }

        function copy_node(node) {
            let n = 1;
            while (document._light.project.json.nodes[node + "" + n]) n++;
            document._light.project.json.nodes[node + "" + n] = document._light.project.json.nodes[node];
            ws.sendPacket("copy_node", {path: document._light.project.path, from: node, to: node + "" + n});
            ws.sendPacket("get_projects");
            addWSOnceListener("get_projects", () => select_node(node + "" + n));
        }

        function toggle_node_lock(node) {
            set_node_locked(node, !document._light.project.json.nodes[node].locked);
        }

        function set_node_locked(node, value) {
            ws.sendPacket("set_node_locked", {path: document._light.project.path, node, value});
            ws.sendPacket("get_projects");
        }

        function switch_node_positions(from, to) {
            ws.sendPacket("switch_node_positions", {path: document._light.project.path, from, to});
            ws.sendPacket("get_projects");
        }

        function set_node_position(node, position) {
            ws.sendPacket("set_node_position", {path: document._light.project.path, node, position});
            ws.sendPacket("get_projects");
        }

        function set_node_group(node, group) {
            ws.sendPacket("set_node_group", {path: document._light.project.path, node, group});
            ws.sendPacket("get_projects");
        }

        addEventListener("click", ev => {
            if (!ev.path.some(i => i.id === "node_menu" || i.id === "left_nav_add"))
                document.getElementById("node_menu").hidden = true;
        });

        const sortNodeKeyPosition = (a, b) => {
            a = document._light.project.json.nodes[a];
            b = document._light.project.json.nodes[b];
            return a.position - b.position;
        };

        const open_groups = {};

        const mapNodeKey = key => `<div draggable="true" id="node_key_${key}">
    <div class="node${document._light.selected_node === key ? " node_selected" : ""}" id="node_pos_${key}" onclick="document._light.select_node('${key}')">
        <img id="node_icon_${key}" draggable="false" class="node_image" src="../assets/${document._light.project.json.nodes[key].type === "group" ? "group_closed" : document._light.project.json.nodes[key].type.replaceAll("-", "_")}.png">
        <span class="node_name">${key === "camera" ? m("camera") : key}</span>
    </div>
    <div title="CTRL + L" onclick="document._light.toggle_node_lock('${key}')" class="${document._light.project.json.nodes[key].locked ? "lock_node" : "unlock_node"} ${document._light.project.json.nodes[key].type !== "camera" ? "ln_1" : "ln_2"}"></div>
    ${document._light.project.json.nodes[key].type === "camera" ? "" : `
    <div title="Delete" onclick="document._light.open_remove_node_menu('${key}')" class="remove_node"></div>
    <div title="F2" onclick="document._light.open_rename_node_menu('${key}')" class="rename_node"></div>
    <div title="CTRL + C" onclick="document._light.copy_node('${key}')" class="copy_node"></div>
    <div id="group_node_content_${key}" style="margin-left: 10px" hidden>${Object.keys(document._light.project.json.nodes).filter(k => document._light.project.json.nodes[k].group === key).sort(sortNodeKeyPosition).map(mapNodeKey).join("")}</div>`}
</div>`;
        let held = {};
        addEventListener("keydown", ev => {
            held[ev.key] = true;
            const node = document._light.selected_node;
            if (node && node !== "camera" && !_p_c && held["Delete"]) open_remove_node_menu(node);
            if (node && node !== "camera" && !_p_c && held["Control"] && (held["C"] || held["c"])) copy_node(node);
            if (node && !_p_c && held["Control"] && (held["L"] || held["l"])) toggle_node_lock(node);
            if (node && node !== "camera" && !_p_c && held["F2"]) open_rename_node_menu(node);
        });
        addEventListener("keyup", ev => delete held[ev.key]);

        function refresh_nodes() {
            for (let i = 0; i < Object.keys(document._light.project.json.nodes).length; i++) {
                const nodeId = Object.keys(document._light.project.json.nodes)[i];
                const node = document._light.project.json.nodes[nodeId];
                if (node.group && !document._light.project.json.nodes[node.group]) {
                    return set_node_group(nodeId, null);
                }
            }
            document.getElementById("nodes").innerHTML = Object.keys(document._light.project.json.nodes).filter(key => !document._light.project.json.nodes[key].group).sort(sortNodeKeyPosition).map(mapNodeKey).join("");
            let currentDragging;
            Object.keys(document._light.project.json.nodes).filter(key => !document._light.project.json.nodes[key].group).forEach(key => {
                const el = document.getElementById("node_key_" + key);
                el.addEventListener("dragstart", ev => {
                    currentDragging = key;
                    ev.dataTransfer.setData("DragID", ev.target.id)
                });
                el.addEventListener("dragover", ev => {
                    ev.preventDefault();
                    if (!currentDragging) return;
                    const targetId = ev.target.id.replace("node_pos_", "");
                    if (targetId !== currentDragging && ev.target.id.startsWith("node_pos_")) el.classList.add("drop_selected");
                });
                el.addEventListener("dragleave", () => el.classList.remove("drop_selected"));
                el.addEventListener("dragend", () => currentDragging = null);
                el.addEventListener("drop", ev => {
                    ev.preventDefault();
                    const dr = ev.dataTransfer.getData("DragID");
                    if (dr && ev.path.some(i => i.id && i.id.startsWith("node_key_") && i.id !== dr)) {
                        const clickedKey = dr.replace("node_key_", "");
                        const draggedKey = key;
                        const clicked = document._light.project.json.nodes[clickedKey];
                        const dragged = document._light.project.json.nodes[draggedKey];
                        if (dragged.type === "group" && clicked.type !== "group") {
                            set_node_group(clickedKey, draggedKey);
                        } else if (clicked.group && dragged.type !== "group") {
                            set_node_group(clickedKey, null);
                            set_node_position(clickedKey, dragged.position + 1);
                            Object.keys(document._light.project.json.nodes)
                                .filter(i => !document._light.project.json.nodes[i].group && document._light.project.json.nodes[i].position > dragged.position)
                                .forEach(i => set_node_position(i, document._light.project.json.nodes[i].position + 1));
                        } else {
                            switch_node_positions(clickedKey, draggedKey);
                        }
                    } else el.style.border = "";
                });
            });
            Object.keys(document._light.project.json.nodes).filter(key => document._light.project.json.nodes[key].type === "group").forEach(i => toggle_group_node(i, true));
        }

        function refresh_properties() {
            const prP = document._light.selected_node && document._light.project.json.nodes[document._light.selected_node].type !== "camera" ? undefined : true;
            document.getElementById("property-remove").src = document._light.property_delete_mode ? '../assets/trash_closed_red.png' : '../assets/trash_closed.png';
            document.getElementById("property-remove").hidden = prP;
            document.getElementById("node-block-script").hidden = prP;
            if (!document._light.selected_node || !document._light.project.json.nodes[document._light.selected_node]) return document.getElementById("properties").innerHTML = "";
            const node = document._light.project.json.nodes[document._light.selected_node];
            const props = node.properties;
            document.getElementById("properties").innerHTML = Object.keys(props).filter(i => props[i].visible !== false).map(key => {
                let input = `<input onchange="document._light.set_node_property('${document._light.selected_node}', '${key}', document.getElementById('node_property_${key}').value)" id="node_property_${key}" spellcheck="false" class="property_value" style="position: absolute; margin-left: -3px; margin-top: -10px; height: 19px" value="${props[key].value === null ? "" : props[key].value}" placeholder="<${languages[lang]["none"]}>">`;
                switch (props[key].type) {
                    case "boolean":
                        input = `<input onchange="document._light.set_node_property('${document._light.selected_node}', '${key}', !!document.getElementById('node_property_${key}').checked)" id="node_property_${key}" type="checkbox" ${props[key].value ? "checked" : ""}>`;
                        break;
                    case "color":
                        input = `<input onchange="document._light.set_node_property('${document._light.selected_node}', '${key}', document.getElementById('node_property_${key}').value)" id="node_property_${key}" type="color" value="${props[key].value}">`
                        break;
                }
                return `
<tr><td class="property_name${document._light.property_delete_mode && !props[key].isDefaultProperty ? ` remove_mode` : ""}"${document._light.property_delete_mode && !props[key].isDefaultProperty ? `onclick="document._light.remove_node_property(document._light.selected_node, '${key}')"` : ""}>${props[key].isDefaultProperty ? languages[lang]["property--" + key] : key}</td><td>
${input}
</td></tr>
`;
            }).join("");
        }

        function select_node(name, v = false) {
            if (name && document._light.project.json.nodes[name].type === "group") return toggle_group_node(name);
            if (document._light.selected_node === name && !v) {
                name = null;
                document._light.property_delete_mode = false;
            }
            const s = name && document._light.project.json.nodes[name].type !== "camera";
            document.getElementById("property-add").hidden = s ? undefined : true;
            document._light.selected_node = name;
            refresh_properties();
            refresh_nodes();
        }

        function toggle_group_node(key, r = false) {
            const node = document._light.project.json.nodes[key];
            if (!node || node.type !== "group") return;
            const gN = document.getElementById("group_node_content_" + key);
            if (!gN) return;
            const is_open = open_groups[key];
            open_groups[key] = !open_groups[key];
            gN.hidden = is_open ? true : undefined;
            document.getElementById("node_icon_" + key).src = "../assets/group_" + (is_open ? "closed" : "open") + ".png";
            if (r) toggle_group_node(key);
        }

        addWSListener("get_language", () => setLanguage(lang, false));
        addWSListener("get_projects", ({projects}) => {
            document._light.project = projects[query.path];
            document.getElementById("title").innerHTML = "Light - " + document._light.project.name;
            if (!projects[query.path].json.nodes[document._light.selected_node]) document._light.selected_node = null;
            refresh_nodes();
            if (sceneType === "editor") setSceneType("editor");
        });
        ws.sendPacket("get_projects");
        /*** @type {"editor" | "game"} */
        let sceneType;
        let sceneCamera = new Vector2(0, 0);
        let sceneZoom = 1.0;
        Scene.ctx = ctx;
        let modelList = {};
        let collisionList = {};

        setInterval(() => {
            ws.sendPacket("set_project_camera", {
                path: document._light.project.path,
                x: sceneCamera.x,
                y: sceneCamera.y
            });
            ws.sendPacket("set_project_zoom", {path: document._light.project.path, zoom: sceneZoom});
        }, 5000);

        const createModel = async ({type, properties}) => {
            switch (type) {
                case "model-image":
                    const model = new ImageModel(
                        properties.x.value * 1,
                        properties.y.value * 1,
                        properties.width.value * 1,
                        properties.height.value * 1,
                        properties.opacity.value * 1
                    );
                    if (properties.image.value) model.setImage(await ImageModel.loadImage(properties.image.value));
                    return model;
                case "model-text":
                    return new TextModel(
                        properties.x.value * 1,
                        properties.y.value * 1,
                        properties.text.value,
                        properties.font.value,
                        properties.size.value * 1,
                        properties.color.value,
                        properties.maxWidth.value * 1 || null,
                        properties.opacity.value * 1
                    );
                case "model-rectangle":
                    return new RectangleModel(
                        properties.x.value * 1,
                        properties.y.value * 1,
                        properties.width.value * 1,
                        properties.height.value * 1,
                        properties.fillColor.value,
                        properties.strokeColor.value,
                        properties.opacity.value * 1
                    );
                case "model-circle":
                    return new CircleModel(
                        properties.x.value * 1,
                        properties.y.value * 1,
                        properties.radius.value,
                        properties.fillColor.value,
                        properties.strokeColor.value,
                        properties.opacity.value * 1
                    );
            }
            return null;
        };
        const createCollision = async props => {
            const scr = await loadProjectScript(props.customScript.value);
            let collisionClass = sceneType === "game" ? scr || RectangleCollision : RectangleCollision;
            let collision;
            try {
                collision = new collisionClass(
                    props.x.value * 1,
                    props.y.value * 1,
                    props.width.value * 1,
                    props.height.value * 1
                );
            } catch (e) {
                collision = new RectangleCollision(
                    props.x.value * 1,
                    props.y.value * 1,
                    props.width.value * 1,
                    props.height.value * 1
                );
            }
            Object.keys(props).filter(i => !props[i].isDefaultProperty).forEach(i => collision[i] = props[i].value);
            collision.offsetX = props.x.value * 1;
            collision.offsetY = props.y.value * 1;
            collision.width = props.width.value * 1;
            collision.height = props.height.value * 1;
            return collision;
        };
        const createEntity = async (props) => {
            const scr = await loadProjectScript(props.customScript.value);
            let entityClass = sceneType === "game" ? scr || Entity : Entity;
            let entity;
            try {
                entity = new entityClass(props.x.value * 1, props.y.value * 1);
            } catch (e) {
                entity = new Entity(props.x.value * 1, props.y.value * 1);
            }
            entity.x = props.x.value * 1;
            entity.x = props.x.value * 1;
            (props.models.value || "").split(",").forEach(m => {
                const mdl = document._light.project.json.nodes[m];
                if (mdl) entity.addModel(modelList[m]);
            });
            (props.collisions.value || "").split(",").forEach(m => {
                const cls = document._light.project.json.nodes[m];
                if (cls) entity.addCollision(collisionList[m]);
            });
            entity.rotation = props.rotation.value;
            entity.gravityEnabled = props.gravityEnabled.value;
            entity.gravity = props.gravity.value;
            entity.terminalGravityVelocity = props.terminalGravityVelocity.value;
            entity.motionDivision = new Vector2(props.motionDivision.value, props.motionDivision.value);
            entity.visible = !props.invisible.value;
            Object.keys(props).filter(i => !props[i].isDefaultProperty).forEach(i => entity[i] = props[i].value);
            return entity;
        };
        const createTile = async (props) => {
            const scr = await loadProjectScript(props.customScript.value);
            let tileClass = sceneType === "game" ? scr || Tile : Tile;
            let tile;
            try {
                tile = new tileClass(props.x.value * 1, props.y.value * 1);
            } catch (e) {
                tile = new Tile(props.x.value * 1, props.y.value * 1);
            }
            tile.x = props.x.value * 1;
            tile.y = props.y.value * 1;
            props.models.value.split(",").forEach(m => {
                const mdl = document._light.project.json.nodes[m];
                if (mdl) tile.addModel(modelList[m]);
            });
            props.collisions.value.split(",").forEach(m => {
                const cls = document._light.project.json.nodes[m];
                if (cls) tile.addCollision(collisionList[m]);
            });
            tile.rotation = props.rotation.value;
            tile.visible = !props.invisible.value;
            Object.keys(props).filter(i => !props[i].isDefaultProperty).forEach(i => tile[i] = props[i].value);
            return tile;
        };
        const refreshModelList = async () => {
            modelList = {};
            const loadingModels = Object.keys(document._light.project.json.nodes).filter(i => document._light.project.json.nodes[i].type.startsWith("model-"));
            for (let i = 0; i < loadingModels.length; i++) {
                const m = loadingModels[i];
                const n = document._light.project.json.nodes[m];
                if (n.type === "model-custom") {
                    if (sceneType === "game") {
                        const scr = await loadProjectScript(n.properties.customScript.value);
                        try {
                            const mdl = new scr(n.properties.x.value * 1, n.properties.y.value * 1, n.properties.opacity.value * 1);
                            mdl.offsetX = n.properties.x.value * 1;
                            mdl.offsetY = n.properties.y.value * 1;
                            mdl.opacity = n.properties.opacity.value * 1;
                            Object.keys(n.properties).filter(i => !n.properties[i].isDefaultProperty).forEach(i => mdl[i] = n.properties[i].value);
                            modelList[m] = mdl;
                        } catch (e) {
                        }
                    }
                } else modelList[m] = await createModel(n);
                if (modelList[m]) modelList[m].init();
            }
        }
        const refreshCollisionList = async () => {
            collisionList = {};
            const loadingCollisions = Object.keys(document._light.project.json.nodes).filter(i => document._light.project.json.nodes[i].type === "collision");
            for (let i = 0; i < loadingCollisions.length; i++) {
                const m = loadingCollisions[i];
                const n = document._light.project.json.nodes[m];
                (collisionList[m] = await createCollision(n.properties)).init();
            }
        }

        let canvasMouseDown = null;
        let selectedEditorEntity = null;
        const mouse = new Vector2(0, 0);
        let mPos = new Vector2(0, 0);
        let collidingCanvas = false;

        let _h = [];
        let copying = false;
        addEventListener("keydown", ev => {
            _h.push(ev.key);
            if (!copying && _h[0] === "Control" && (_h[1] === "C" || _h[1] === "c")) {
                copying = true;
            }
        });
        addEventListener("keyup", ev => {
            _h = _h.filter(i => i !== ev.key);
            if (_h.length < 2) copying = false;
        });
        addEventListener("blur", () => _h = []);

        addEventListener("mousemove", ev => {
            mouse.x = ev.clientX;
            mouse.y = ev.clientY;
            collidingCanvas = ev.path[0].id === "canvas";
            mPos = Scene.getInstance().camera.add(ev.offsetX, ev.offsetY).floor();
        });

        canvas.addEventListener("mousemove", ev => {
            if (!canvasMouseDown) return;
            if (selectedEditorEntity) {
                const pos = canvasMouseDown[2].subtract(canvasMouseDown[0].subtract(ev.offsetX, ev.offsetY));
                const nodeId = selectedEditorEntity["__nodeId"];
                document._light.project.json.nodes[nodeId].properties.x.value = pos.x;
                document._light.project.json.nodes[nodeId].properties.y.value = pos.y;
                refresh_properties();
                selectedEditorEntity.x = pos.x;
                selectedEditorEntity.y = pos.y;
                (selectedEditorEntity.collisionTiles || []).forEach(t => {
                    if (!t) return;
                    t.x = pos.x;
                    t.y = pos.y;
                });
            } else {
                const newCamera = canvasMouseDown[1].add(canvasMouseDown[0].subtract(ev.offsetX, ev.offsetY));
                sceneCamera.x = newCamera.x;
                sceneCamera.y = newCamera.y;
            }
        });

        const getEntitiesByMouse = (x, y) => {
            const cmr = (new Vector2(x + sceneCamera.x, y + sceneCamera.y));
            return Scene.getInstance().entities.filter(entity => entity instanceof Entity && (entity.collides(cmr))).filter(i => i["__nodeId"] ? !document._light.project.json.nodes[i["__nodeId"]].locked : true);
        };

        canvas.addEventListener("mousedown", ev => {
            canvasMouseDown = [new Vector2(ev.offsetX, ev.offsetY), Scene.getInstance().camera.clone()];
            if (sceneType === "editor") {
                selectedEditorEntity = getEntitiesByMouse(ev.offsetX, ev.offsetY);
                selectedEditorEntity = document._light.selected_node ? (selectedEditorEntity.find(i => i && i["__nodeId"] === document._light.selected_node) || selectedEditorEntity[0]) : selectedEditorEntity[0];
                if (selectedEditorEntity) canvasMouseDown[2] = selectedEditorEntity.clone();
            }
        });

        addEventListener("mouseup", ev => {
            if (sceneType === "editor" && canvasMouseDown && canvasMouseDown[0] && canvasMouseDown[0].equals(new Vector2(ev.offsetX, ev.offsetY))) {
                const ent = getEntitiesByMouse(ev.offsetX, ev.offsetY)[0];
                if (ent && ent["__nodeId"]) select_node(ent["__nodeId"]);
            }
            if (selectedEditorEntity && canvasMouseDown) {
                const nodeId = selectedEditorEntity["__nodeId"];
                set_node_properties(nodeId, document._light.project.json.nodes[nodeId].properties);
            }
            selectedEditorEntity = null;
            canvasMouseDown = false;
        });

        canvas.addEventListener("wheel", ev => {
            if (sceneType !== "editor") return;
            if (ev.deltaY > 0) Scene.instance.zoom -= 0.1;
            else if (ev.deltaY < 0) Scene.instance.zoom += 0.1;
            sceneZoom = Scene.instance.zoom;
        });

        let setupCamera = false;
        let cameraTile = new Tile(0, 0);
        cameraTile.__nodeId = "camera";

        addEventListener("resize", () => {
            if (!cameraTile) return;
            cameraTile.model.setWidth(canvas.width).setHeight(canvas.height);
            cameraTile.collision.setWidth(canvas.width).setHeight(canvas.height);
        });

        let scene_process = false;
        let _sid = 0;

        async function setSceneType(type) {
            const sid = _sid++;
            scene_process = sid;
            const cameraNode = document._light.project.json.nodes.camera;
            if (!cameraNode) return window.location.href = window.location.href.toString();
            document._light.loadedScriptList = {};
            cameraTile.model = new RectangleModel(0, 0, canvas.width, canvas.height, null, themes[theme].json["general-color"]);
            cameraTile.addModel(cameraTile.model);
            cameraTile.collision = new RectangleCollision(0, 0, canvas.width, canvas.height);
            cameraTile.addCollision(cameraTile.collision);
            sceneType = type;
            switch (sceneType) {
                case "editor":
                    Scene.getInstance().destroy();
                    Scene.getInstance().camera = sceneCamera;
                    Scene.getInstance().zoom = sceneZoom;
                    Scene.getInstance().cameraTile = cameraTile;
                    Scene.getInstance().onUpdateStart = () => {
                        ctx.fillStyle = cameraNode.properties.color.value.toString();
                        ctx.fillRect(-sceneCamera.x + cameraTile.x, -sceneCamera.y + cameraTile.y, canvas.width * Scene.instance.zoom, canvas.height * Scene.instance.zoom);
                        ctx.fillStyle = "rgb(0, 255, 0)";
                        ctx.fillRect(0, -sceneCamera.y, canvas.width, 1);
                        ctx.fillStyle = "rgb(255, 0, 0)";
                        ctx.fillRect(-sceneCamera.x, 0, 1, canvas.height);
                    }
                    Scene.getInstance().onUpdateEnd = () => {
                        ctx.fillStyle = themes[theme].json["general-color"];
                        ctx.font = "16px Calibri";
                        ctx.fillText(sceneType === "editor" && collidingCanvas ? `X: ${mPos.x}, Y: ${mPos.y}, Zoom: ${Math.floor(Scene.getInstance().zoom * 100)}%` : "", 4, 16);
                    }
                    if (!setupCamera) {
                        setupCamera = true;
                        sceneCamera.x = -canvas.width / 2;
                        sceneCamera.y = -canvas.height / 2;
                    }
                    await refreshModelList();
                    await refreshCollisionList();
                    const nList = Object.keys(document._light.project.json.nodes).sort((a, b) => document._light.project.json.nodes[b].position - document._light.project.json.nodes[a].position).filter(i => ["entity", "tile", "text", "camera", "light"].includes(document._light.project.json.nodes[i].type)).sort((a, b) => document._light.project.json.nodes[a].position - document._light.project.json.nodes[b].position);
                    for (const j of nList) {
                        const i1 = document._light.project.json.nodes[j];
                        switch (i1.type) {
                            case "entity":
                                const entity = await createEntity(i1.properties);
                                entity.update = r => r;
                                if (entity) entity.init();
                                entity.__nodeId = j;
                                entity.collisionTiles = [];
                                if (i1.properties.collisionBorder.value) entity.collisions.forEach(i => {
                                    if (!(i instanceof RectangleCollision)) return;
                                    const t = new Tile(entity.x, entity.y);
                                    t.addModel(new RectangleModel(i.offsetX, i.offsetY, i.width, i.height, null, themes[theme].json["general-color"]));
                                    t.init();
                                    entity.collisionTiles.push(t);
                                });
                                break;
                            case "tile":
                                const tile = await createTile(i1.properties);
                                tile.update = r => r;
                                if (tile) tile.init();
                                tile.__nodeId = j;
                                tile.collisionTiles = [];
                                if (i1.properties.collisionBorder.value) tile.collisions.forEach(i => {
                                    if (!(i instanceof RectangleCollision)) return;
                                    const t = new Tile(tile.x, tile.y);
                                    t.addModel(new RectangleModel(i.offsetX, i.offsetY, i.width, i.height, null, themes[theme].json["general-color"]));
                                    t.init();
                                    tile.collisionTiles.push(t);
                                });
                                break;
                            case "text":
                                const textTile = new Tile(0, 0);
                                textTile.x = i1.properties.x.value * 1;
                                textTile.y = i1.properties.y.value * 1;
                                const textModel = await createModel({type: "model-text", properties: i1.properties});
                                textModel.offsetX = 0;
                                textModel.offsetY = 0;
                                textTile.addModel(textModel);
                                textTile.init();
                                textTile.__nodeId = j;
                                const size = TextModel.calculateTextSize(textModel.text, textModel.size, textModel.font, textModel.maxWidth);
                                const coll = new RectangleCollision(0, textModel.size / 3, size.width, size.height);
                                textTile.addCollision(coll);
                                if (i1.properties.collisionBorder.value) {
                                    const t = new Tile(textTile.x, textTile.y);
                                    t.addModel(new RectangleModel(0, textModel.size / 3, size.width, size.height, null, themes[theme].json["general-color"]));
                                    t.init();
                                    textTile.collisionTiles = [t];
                                }
                                break;
                            case "camera":
                                cameraTile.x = i1.properties.x.value * 1;
                                cameraTile.y = i1.properties.y.value * 1;
                                cameraTile.init();
                                break;
                            case "light":
                                const rayCast = new RayCast(0, 0, i1.properties.power.value);
                                const ray = new RayCastEntity(rayCast, i1.properties.x.value * 1, i1.properties.y.value * 1);
                                if (i1.properties.collisionBorder.value) {
                                    ray.addModel(ray.model = (new RectangleModel(-25, -25, 50, 50, null, themes[theme].json["general-color"])));
                                    ray.addModel(new RectangleModel(-5, -5, 10, 10, null, themes[theme].json["general-color"]));
                                }
                                ray.collision = new RectangleCollision(-25, -25, ray.model.width, ray.model.height);
                                ray.addCollision(ray.collision)
                                    .addModel(new RayCastModel(0, 0, i1.properties.color.value, rayCast, i1.properties.opacity.value));
                                ray.setStartAngle(i1.properties.startAngle.value)
                                    .setEndAngle(i1.properties.endAngle.value)
                                    .setRayPopulation(i1.properties.rayPopulation.value)
                                    .setLightenCamera(i1.properties.lightenCamera.value)
                                    .setInactiveNodes((i1.properties.inactiveNodes.value || "").split(","));
                                ray.init();
                                ray.visible = !i1.properties.invisible.value;
                                ray.__nodeId = j;
                                break;
                        }
                    }
                    start_btn.hidden = undefined;
                    stop_btn.hidden = true;
                    break;
                case "game":
                    consoleList = [];
                    renderConsole();
                    Scene.getInstance().destroy();
                    Scene.getInstance().camera.set(cameraNode.properties.x.value, cameraNode.properties.y.value);
                    Scene.getInstance().onUpdateStart = () => {
                        ctx.fillStyle = cameraNode.properties.color.value.toString();
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                    };
                    await refreshModelList();
                    await refreshCollisionList();
                    for (const j of Object.keys(document._light.project.json.nodes).sort((a, b) => document._light.project.json.nodes[b].position - document._light.project.json.nodes[a].position).filter(i => ["entity", "tile", "text", "script", "light"].includes(document._light.project.json.nodes[i].type))) {
                        const i1 = document._light.project.json.nodes[j];
                        switch (i1.type) {
                            case "entity":
                                const entity = await createEntity(i1.properties);
                                if (entity) entity.init();
                                entity.__nodeId = j;
                                break;
                            case "tile":
                                const tile = await createTile(i1.properties);
                                if (tile) tile.init();
                                tile.__nodeId = j;
                                break;
                            case "text":
                                const textTile = new Tile(0, 0);
                                const textModel = await createModel({type: "model-text", properties: i1.properties});
                                textTile.addModel(textModel);
                                textTile.init();
                                textTile.__nodeId = j;
                                break;
                            case "script":
                                if (!i1.properties.file.value) continue;
                                const script = await loadProjectScript(i1.properties.file.value, false);
                                if (script) continue;
                                try {
                                    const scr = new script();
                                    Object.keys(i1.properties).forEach(i => scr[i] = i1.properties[i].value);
                                    if (scr.init) scr.init();
                                } catch (e) {
                                    console.error(e);
                                    const f = i1.properties.file.value;
                                    if (f) {
                                        console.info(`Script with file '${i1.properties.file.value}' gave error!`);
                                        log(e, f);
                                    }
                                }
                                break;
                            case "light":
                                const rayCast = new RayCast(0, 0, i1.properties.power.value);
                                const ray = new RayCastEntity(rayCast, i1.properties.x.value * 1, i1.properties.y.value * 1);
                                ray.addModel(new RayCastModel(0, 0, i1.properties.color.value, rayCast, i1.properties.opacity.value))
                                ray.setStartAngle(i1.properties.startAngle.value)
                                    .setEndAngle(i1.properties.endAngle.value)
                                    .setRayPopulation(i1.properties.rayPopulation.value)
                                    .setLightenCamera(i1.properties.lightenCamera.value)
                                    .setInactiveNodes((i1.properties.inactiveNodes.value || "").split(","));
                                ray.init();
                                ray.visible = !i1.properties.invisible.value;
                                ray.__nodeId = j;
                                break;
                        }
                    }
                    start_btn.hidden = true;
                    stop_btn.hidden = undefined;
                    break;
            }
        }

        addWSOnceListener("get_projects", () => {
            setSceneType("editor");
            sceneCamera.x = document._light.project.json.camera.x;
            sceneCamera.y = document._light.project.json.camera.y;
            sceneZoom = document._light.project.json.zoom || 1.0;
            Scene.instance.zoom = sceneZoom;
        });

        function main_menu() {
            window.location.href = "index.html";
            ws.sendPacket("main_menu");
        }

        function open_logs() {
            prompt(m("logs-title"), "<div style='height: 100px;overflow-y: scroll;'>" + (document._light.project.actions || []).map(action => {
                return `<div class="action">
    <div>${action.id}</div>
    <!--<div>${JSON.stringify(action.from)}</div>
    <div>${JSON.stringify(action.to)}</div>-->
</div>`
            }).reverse().join("") + "</div>", m("okay-button"), false);
        }

        setInterval(() => {
            const canvas = document.getElementById("canvas");
            if (canvas.width !== Math.floor(window.innerWidth * 0.601)) canvas.width = Math.floor(window.innerWidth * 0.601);
            if (canvas.height !== Math.floor(window.innerHeight * 0.751)) canvas.height = Math.floor(window.innerHeight * 0.751);
        });

        addWSListener("get_file", ({path, exists, type}) => {
            if (path === query.path && (!exists || type !== "folder")) main_menu();
        });

        function checkProjectExists() {
            ws.sendPacket("get_file", {path: query.path});
        }

        function block_code(node) {
            window.location.href = "./block.html?" + window.location.href.split("?")[1] + "&node=" + node;
        }

        window.addEventListener("blur", checkProjectExists);
        document._light = {
            main_menu,
            open_logs,
            setSceneType,
            open_node_menu,
            open_property_menu,
            select_node,
            end_prompt,
            open_add_node_menu,
            open_remove_node_menu,
            open_rename_node_menu,
            copy_node,
            toggle_node_lock,
            selected_node: null,
            set_node_property,
            refresh_properties,
            remove_node_property,
            property_delete_mode: false,
            block_code,
            loadedScriptList: []
        };
    })();
    const loadProjectScript = async (file, addToList = true) => {
        if (!file) return null;
        if (document._light.loadedScriptList[file]) return document._light.loadedScriptList[file];
        file = /\w:\//i.test(file.substring(0, 3)) ? file : (file.startsWith(".") ? (file.startsWith("./") && /\w/i.test(file.charAt(2)) ? document._light.project.path + "/" + file.substring(2) : file) : document._light.project.path + "/" + file);
        const script = await loadScript(file);
        if (script.error) {
            log("Invalid script.", file);
            return console.info(`Script with file '${file}' not found or a folder!`);
        }
        const code = script.code;
        const ____________i = setInterval;
        const ____________t = setTimeout;
        const ____________c = console;
        const ____________e = eval;
        const ____________x = XMLHttpRequest;
        console = null;
        eval = null;
        XMLHttpRequest = null;
        setInterval = (...args) => Scene.intervals.push(____________i(...args));
        setTimeout = (...args) => Scene.intervals.push(____________t(...args));
        exports = null;
        try {
            (() => {
                ____________e(code.length === 0 ? "null" : code);
                if (addToList) document._light.loadedScriptList[file] = exports;
            })();
        } catch (e) {
            ____________c.error(e);
            if (file) {
                ____________c.info(`Script with file '${file}' gave error!`);
                log(e, file);
            }
        }
        window.XMLHttpRequest = ____________x;
        window.eval = ____________e;
        window.setInterval = ____________i;
        window.setTimeout = ____________t;
        window.console = ____________c;
        return exports;
    }
</script>
</html>
